
/*
 * Generated by ChatGPT
 *
 * Minimal standalone libc implementations:
 * strcmp, strncmp, memcpy, memset, strchr, vsnprintf, snprintf
 *
 * File: /d:/dev/barf/src/libc/libc.c
 *
 * These implementations are simple, portable, and do not depend on
 * other libc functions. vsnprintf/snprintf implement a small subset of printf
 * format specifiers: %s, %c, %d, %i, %u, %x, %X, %p, and %%.
 *
 * vsnprintf follows C99 semantics: it returns the number of characters
 * that would have been written (excluding the terminating null byte),
 * even if the output was truncated. If size > 0 the result is always
 * NUL-terminated.
 */

#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>


/* strlen: return length of string */
size_t strlen(const char *a) {
    size_t length = 0;
    while (a[length] != 0) length++;
    return length;
}

/* memcpy: copy n bytes from src to dst. Behavior for overlapping regions
   is undefined (like the standard memcpy). */
char* strcpy(char *dst, const char *src)
{
    int length = 0;
    while (src[length] != 0) {
        dst[length] = src[length];
        length++;
    }
    return dst;
}

/* strcmp: compare two NUL-terminated strings */
int strcmp(const char *a, const char *b)
{
    const unsigned char *ua = (const unsigned char *)a;
    const unsigned char *ub = (const unsigned char *)b;
    while (*ua && (*ua == *ub)) {
        ua++;
        ub++;
    }
    return (int)(*ua - *ub);
}

/* strncmp: compare up to n bytes of two NUL-terminated strings */
int strncmp(const char *a, const char *b, size_t n)
{
    const unsigned char *ua = (const unsigned char *)a;
    const unsigned char *ub = (const unsigned char *)b;
    size_t i = 0;
    if (n == 0) return 0;
    while (i < n && *ua && (*ua == *ub)) {
        ua++;
        ub++;
        i++;
        if (i == n) break;
    }
    if (i == n) return 0;
    return (int)(*ua - *ub);
}

/* memcpy: copy n bytes from src to dst. Behavior for overlapping regions
   is undefined (like the standard memcpy). */
void *memcpy(void *dst, const void *src, size_t n)
{
    unsigned char *d = (unsigned char *)dst;
    const unsigned char *s = (const unsigned char *)src;
    size_t i;
    for (i = 0; i < n; ++i)
        d[i] = s[i];
    return dst;
}

/* memset: set n bytes of s to byte value c */
void *memset(void *s, int c, size_t n)
{
    unsigned char *p = (unsigned char *)s;
    unsigned char uc = (unsigned char)c;
    size_t i;
    for (i = 0; i < n; ++i)
        p[i] = uc;
    return s;
}

/* strchr: locate first occurrence of character c in string s */
char *strchr(const char *s, int c)
{
    unsigned char uc = (unsigned char)c;
    while (*s) {
        if ((unsigned char)*s == uc)
            return (char *)s;
        s++;
    }
    if (uc == 0) /* NUL terminator requested */
        return (char *)s;
    return NULL;
}

// #include <ctype.h>
#include <limits.h>

unsigned long strtoul(const char *nptr, char **endptr, int base)
{
    const char *s = nptr;
    unsigned long result = 0;
    int negative = 0;
    int any = 0;



    // Skip leading whitespace
    while (s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r')
        s++;

    // Optional sign
    if (*s == '+') {
        s++;
    } else if (*s == '-') {
        negative = 1;
        s++;
    }

    // Base detection
    if (base == 0) {
        if (*s == '0') {
            if (s[1] == 'x' || s[1] == 'X') {
                base = 16;
                s += 2;
            } else {
                base = 8;
                s++;
            }
        } else {
            base = 10;
        }
    } else if (base == 16) {
        if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
            s += 2;
        }
    }

    unsigned long cutoff = ULONG_MAX / base;
    unsigned long cutlim = ULONG_MAX % base;

    for (; *s; s++) {
        int digit;

        if (*s >= '0' && *s <= '9')
            digit = *s - '0';
        else if (*s >= 'A' && *s <= 'Z')
            digit = *s - 'A' + 10;
        else if (*s >= 'a' && *s <= 'z')
            digit = *s - 'a' + 10;
        else
            break;

        if (digit >= base)
            break;

        if (result > cutoff || (result == cutoff && digit > cutlim)) {
            result = ULONG_MAX; // overflow
            any = -1;
        } else {
            any = 1;
            result = result * base + digit;
        }
    }

    if (endptr)
        *endptr = (char *)(any ? s : nptr);

    if (negative)
        return (unsigned long)(-result);

    return result;
}




/* Internal helpers for snprintf/vsnprintf implementation */

/* Append a single character to buffer if space remains. Always
   increments *written (the would-be total). */
static void sb_putc(char *buf, size_t size, size_t *pos, char ch)
{
    if (*pos + 1 < size) {
        buf[*pos] = ch;
    }
    (*pos)++;
}

/* Append a NUL-terminated string to buffer, return length added */
static void sb_puts(char *buf, size_t size, size_t *pos, const char *s)
{
    while (*s) {
        sb_putc(buf, size, pos, *s++);
    }
}

/* Convert unsigned integer value to string in given base.
   digits buffer must be large enough. Produces digits in reverse order. Returns length. */
static int utoa_rev(unsigned long long value, unsigned int base, char *digits, int uppercase)
{
    const char *low = "0123456789abcdef";
    const char *up  = "0123456789ABCDEF";
    const char *map = uppercase ? up : low;
    int len = 0;
    if (value == 0) {
        digits[len++] = '0';
        return len;
    }
    while (value != 0) {
        digits[len++] = map[value % base];
        value /= base;
    }
    return len;
}

/* vsnprintf: minimal implementation using a va_list */
int vsnprintf(char *str, size_t size, const char *fmt, va_list ap)
{
    size_t pos = 0; /* number of characters that would have been written (excluding final NUL) */

    while (*fmt) {
        if (*fmt != '%') {
            sb_putc(str, size, &pos, *fmt++);
            continue;
        }

        /* handle format */
        fmt++; /* skip '%' */
        if (*fmt == '%') {
            sb_putc(str, size, &pos, '%');
            fmt++;
            continue;
        }

        /* No support for flags, width, precision, or length modifiers except pointer */
        int uppercase = 0;
        switch (*fmt) {
            case 's': {
                const char *s = va_arg(ap, const char *);
                if (!s) s = "(null)";
                sb_puts(str, size, &pos, s);
                fmt++;
                break;
            }
            case 'c': {
                int c = va_arg(ap, int);
                sb_putc(str, size, &pos, (char)c);
                fmt++;
                break;
            }
            case 'd':
            case 'i': {
                int v = va_arg(ap, int);
                unsigned int uv;
                if (v < 0) {
                    sb_putc(str, size, &pos, '-');
                    uv = (unsigned int)(-(long long)v);
                } else {
                    uv = (unsigned int)v;
                }
                char rev[32];
                int rl = utoa_rev((unsigned long long)uv, 10, rev, 0);
                for (int i = rl - 1; i >= 0; --i) sb_putc(str, size, &pos, rev[i]);
                fmt++;
                break;
            }
            case 'u': {
                unsigned int uv = va_arg(ap, unsigned int);
                char rev[32];
                int rl = utoa_rev((unsigned long long)uv, 10, rev, 0);
                for (int i = rl - 1; i >= 0; --i) sb_putc(str, size, &pos, rev[i]);
                fmt++;
                break;
            }
            case 'x':
            case 'X': {
                if (*fmt == 'X') uppercase = 1;
                unsigned int uv = va_arg(ap, unsigned int);
                char rev[32];
                int rl = utoa_rev((unsigned long long)uv, 16, rev, uppercase);
                for (int i = rl - 1; i >= 0; --i) sb_putc(str, size, &pos, rev[i]);
                fmt++;
                break;
            }
            case 'p': {
                void *p = va_arg(ap, void *);
                unsigned long long addr = (unsigned long long)(uintptr_t)p;
                sb_puts(str, size, &pos, "0x");
                char rev[32];
                int rl = utoa_rev(addr, 16, rev, 0);
                for (int i = rl - 1; i >= 0; --i) sb_putc(str, size, &pos, rev[i]);
                fmt++;
                break;
            }
            default:
                /* Unknown specifier: treat literally (write '%' and the char) */
                sb_putc(str, size, &pos, '%');
                if (*fmt) {
                    sb_putc(str, size, &pos, *fmt);
                    fmt++;
                }
                break;
        }
    }

    /* Null-terminate if possible */
    if (size > 0) {
        size_t nulpos = (pos < size) ? pos : (size - 1);
        str[nulpos] = '\0';
    }

    /* Return number of characters that would have been written (not counting final NUL) */
    if (pos > (size_t)INTPTR_MAX) /* avoid returning absurd huge values on overflow */
        return (int)INTPTR_MAX;
    return (int)pos;
}

/* snprintf: convenience wrapper around vsnprintf */
int snprintf(char *str, size_t size, const char *fmt, ...)
{
    va_list ap;
    int ret;
    va_start(ap, fmt);
    ret = vsnprintf(str, size, fmt, ap);
    va_end(ap);
    return ret;
}
